---
title: "可愛がりたくなるようなテストコードを作りたいんだ（真顔）"
emoji: "🫶"
type: "idea"
topics:
  - "テスト設計"
  - "test"
  - "typescript"
  - "jest"
  - "vitest"
published: false
---

## はじめに

### この記事について

25卒新米エンジニアの岩田と申します。

テストコードを書いたことがないエンジニア、またはAIに書かせるだけで思想がまるでない私のようなエンジニアにとって、テストコードの作成に対してこのような印象を持っていることに共感していただける方が多いのかなと思っています。

- テストコードを書くための構文を覚えるのが面倒臭くて、テストコード自体を読むこと自体に拒絶反応を起こす
- そもそも何をどの粒度でテストをすれば良いのか分からないために手をつけられない
- とりあえずAIにテストコードを作成してもらったけど、善し悪しを評価できないためにそのままコミットすることしかできない

自分も含め、上記の状態で作成されるテストコードは、もはや作成されたというよりは生成されたという表現の方が正しく感じるほどです。このようなテストコードはほぼ100%、開発途中で忘れ去られるか、開発スピードを下げるボトルネックとして鎮座し続けることになってしまうかと思います。

そこで、後で紹介させていただきますが、テスト設計に関する書籍に手を伸ばして勉強してみました。そうすると、自分の中である程度テスト設計についての思想を持つことができるようになりました。この記事では実際にそれにより得られた知識を使って、保守性の欠片もないコードをリファクタリングしながらテストコードを作成していきたいと思います。

この記事は自分の知識をアウトプットして定着させることを第一の目的として書きましたが、私と同じような方々の羅針盤になったとしたら、この上なく喜ばしく思います。また、中身のレベルとして偏った視点からでの見方が散見されるかと思いますので、ご容赦いただきたいことに加えて、ご教授いただけますと幸いです。

### 対象者

この記事の読者としては、以下を想定しています。

- 紹介書籍を購入しようか迷っている方
- テストコードを書こうと思ったが、何をどの粒度で書けばいいか分からずに諦めてしまった方
- テストコードを書いた経験はあるが、なんとなくでしか書いたことのない方

### 参考書籍紹介

https://book.mynavi.jp/ec/products/detail/id=134252

### サンプルコード

説明用のプログラムとして、ショッピングサイトで使えそうで使えないものを作成してみました。機能面もそこまで深くは考えていないので、関数ごとの関係や外部のソフトウェアとの連携などの技術的な側面のみに目を当ててくださると非常に助かります。
初期状態として、ひとつのファイル内のひとつの関数に全ての機能を盛り込んだ状態からスタートします。そんな禍々しい初期状態のコードは、以下のアコーディオンを開くと閲覧することができます。

:::details 初期状態
```ts:テスト
import nodemailer from "nodemailer";
import axios, { AxiosRequestConfig } from "axios";

type Product = {
  id: number;
  name: string;
  price: number; // 税抜価格
};

export class ProductService {
  private apiUrl: string = "https://example.com/api";
  private taxRate: number = 0.1;
  private transporter = nodemailer.createTransport({
    host: "smtp.example.com", // 例: smtp.gmail.com
    port: 587,
    secure: false, // TLS
    auth: {
      user: "test@example.com",
      pass: "password",
    },
  });

  /**
   * @description 商品情報をIDから取得する
   */
  async fetchProduct(props: { productId: number }): Promise<Product> {
    const config: AxiosRequestConfig = {
      headers: { "Content-Type": "application/json" },
      timeout: 5000,
      withCredentials: true,
    };

    try {
      const response = await axios.get<Product>(
        `${this.apiUrl}/products/${props.productId}`,
        config
      );
      return response.data;
    } catch (error) {
      throw new Error("商品情報の取得に失敗しました");
    }
  }

  /**
   * @description 税込価格に補正する
   */
  calculateTaxIncludedPrice(props: { price: number }): number {
    return Math.round(props.price * (1 + this.taxRate));
  }

  /**
   * @description 商品情報を加工して、名前と税込価格を返す
   */
  async getProcessedProductInfo(props: { productId: number }): Promise<string> {
    const product = await this.fetchProduct({ productId: props.productId });
    const taxIncluded = this.calculateTaxIncludedPrice({
      price: product.price,
    });
    return `商品名: ${product.name} / 税込価格: ¥${taxIncluded}`;
  }

  /**
   * @description メールを送信する
   */
  async sendEmail(props: {
    to: string;
    subject: string;
    body: string;
  }): Promise<void> {
    try {
      await this.transporter.sendMail({
        from: '"Your App Name" <your_username@example.com>',
        to: props.to,
        subject: props.subject,
        text: props.body,
      });
      console.log(`メールを送信しました: ${props.to}`);
    } catch (error) {
      console.error("メール送信に失敗しました:", error);
      throw new Error("メール送信に失敗しました");
    }
  }

  /**
   * @description 商品情報をメールで送信する
   */
  async sendProductInfoByEmail(props: {
    productId: number;
    email: string;
  }): Promise<void> {
    const productInfo = await this.getProcessedProductInfo({
      productId: props.productId,
    });
    this.sendEmail({
      to: props.email,
      subject: "商品情報のお知らせ",
      body: productInfo,
    });
  }
}
```
:::

私の作成した最悪傑作はいかがでしたか？
この規模感であれば管理のしようがありますが、これが大規模なプロジェクトでまかり通ってしまった暁には、巷でいう「大きな泥団子」になってしまいます。そもそもこんなコードを作ろうとする知的生命体が地球上にいるのかどうかというのは置いといて。この泥団子を３色団子のように役割を明確に分割して管理のしやすいコードへ変化させ、さらに管理コストを削減するためのテストコードを書いていこうと思います。

:::message
GPTに仕様を伝えてコードの大半を作成してもらいましたが、なんせGPTは優秀ゆえ読みやすいコードを生成してくれるので、生成してくれたものに手を加えて改悪するのにぼちぼち時間を要しました。普段の使い方とは真逆で、いつもとは脳みその別の部分を使っている感覚が何かと新鮮で楽しかったので、あまりにも暇を持て余している方は是非やってみてください。
:::

## テスト設計の考え方

まずは、テスト設計について考える上での根底の認識の擦り合わせをしようと思います。

### 質の高いテストコードの定義

ここでは「質が高い」という形容詞の定義をしようと思います。
先にイメージを掴みやすい用に、この上なく抽象的な定義をしておくとすれば、「**開発における保守コストを下げる**」になるかと思います。

ではもう少し具体的な定義をしましょう。
質の高いテストスイート（テストケース群のこと）を以下のように定義します。

- 開発サイクルにテストが含まれている
- ドメインモデルを中心にテストされている
- 最小限の保守コストで最大限の価値を生み出せている

#### 開発サイクルにテストが含まれている

開発の一連のサイクルの中にテストが含まれていることは質の高いテストの前提条件になります。

#### ドメインモデルを中心にテストされている

ソフトウェア内のすべてのコードに対してテストを実装することは、返って保守コストを上げてしまう可能性が高いです。

#### 最小限の保守コストで最大限の価値を生み出せている

ニュアンス的には、最小限のテストコードで最大限の価値を創出するということになります。前述の通り、ソフトウェア内の全てに対してテストを実装する必要はありません。なんならテストコードを書いてまで、セーフティネットを張りたい箇所にだけテストを書けば十分です。
もちろん、どのようなテストフォーマットが最大限の価値を生み出すのかは、最終的にプロジェクトの性質に帰着することになります。

### 単体テストと統合テスト

少し本題から外れる気がしますが、単体テストと統合テストをそれぞれ定義しておこうと思います。

#### 単体テスト

単体テストを、以下の3つの条件を**全て**満たすものとして定義します。

- 1単位の振る舞いを検証すること
- 実行時間が短いこと
- 他のテストケースから隔離された状態で実行されること

##### 1単位の振る舞いを検証すること

単体テストでは、1つのテストスイートで複数のテストを一度には行いません。もちろん単体という名前がついているので、当たり前とえばそうですが。
ここで重要なのは後述しますが、1単位の**振る舞い**となっている点です。1単位の**コード**ではありません。言い換えるとすれば、テスト対象の選定にはホワイトボックス的ではなく、ブラックボックス的に行うと考えるということです（グレーボックスというのが最も適切なような気がしますが）

##### 実行時間が短いこと

実行時間が短いということも条件になります。

##### 他のテストケースから隔離された状態で実行されること

他のテストケースから隔離されているというのは、単体テストのそれぞれのテストケースが、他のテストケースの結果や実行状態に依存しないということです。
例えば、あるテストケースが実行されたことによって作成されたデータを用いて、他のテストケースが正常の走るようになるなどの、テストケース間での依存がある場合は単体テストではないということです。

#### 統合テスト

統合テストの定義自体はシンプルで、単体テストの満たす3つの性質のうち、ひとつでも満たさないものがあるようなテストと定義します。
例えばE2Eテストは分かりやすい例で、1単位の振る舞いでもないし、実行時間は長いし、テストケースごとの分離は設定しない限り全くと言ってほど無いかと思います。

## コードのリファクタリング

ここまでテストに関する前提について説明してきましたが、ここでは効果の高いテストコードを作成するためにプロダクションコードのリファクタリングをします。テストコードの質は、その中身自体にも当たり前に依存することに加え、プロダクションコードの設計にも強く依存します。

### プロセス外依存の隔離

まずは、ソフトウェア間依存の一つである「プロセス外依存」と呼ばれるものを分離した設計に変更します。簡単に表現するとすれば、

### プロダクションコードの分類

次に、コードの分類をしていこうと思います。
ここでの分類は、テスト設計のガイドラインになるものです。

コードは以下の観点で分類することができます。

- コードの複雑さ・ドメインにおける重要性
- 協力者オブジェクトの数

これにより、コードを4種類に以下のように分類することができます。

- ドメインモデル・アルゴリズム
- コントローラ
- 過度に複雑なコード
- 取るに足らないコード

※テストが価値を発揮しやすいものから順番に列挙しています。

:::message
金のなる木とかと雰囲気が似てますね
:::

#### ドメインモデル・アルゴリズム

まずは、「ドメインモデル・アルゴリズム」の部分について説明していこうと思います。
エンジニア組織で例えるとすれば、テックリード的な立ち位置かと思います。

#### コントローラ

次はコントローラですが、こちらはMVCアーキテクチャでいうそれと比べて、広義的な意味での表現になります。
エンジニア組織で例えるとすれば、プロジェクトマネージャ的な立ち位置かと思います。

:::message
マイクロカーネルアーキテクチャと呼ばれるアーキテクチャは、このコントローラをソフトウェア設計の基盤に置いたようなものになっているように個人的に感じています。
:::

#### 過度に複雑なコード

過度に複雑なコードというのは、ドメインとして重要であるにも関わらず、コードが複雑で協力者オブジェクトが多い、いわば管理しにくいけど管理しないといけないコードのことです。
エンジニア組織で例えるとすれば、月の平均残業時間が100時間超えてるマネージャ的な立ち位置かと思います。
単純に読みやすい状態にするためにも、テスト設計をしやすくするためにも、このコードを適切に「ドメインモデル・アルゴリズム」「コントローラ」

:::message
質素なオブジェクト
:::

#### 取るに足らないコード

エンジニア組織で例えるとしたいところですが、これは角が立ちそうなのでやめておきます。

## テストコードの作成

ここから本題のテストコードの作成をしていきます。

### テスト対象と方法の決定

まずは、何をどのようにテストすればいいのかについて整理したいと思います。

#### テスト対象

そもそもまず何をテストすればいいのか。テスト対象を決定する際の根本的な考え方は、1単位の振る舞いを検証するというものです。よくあるケースとしては、1単位のコードに対してテストを記述するというものです。こちらはアンチパターンというほどのレベルではないですが、リファクタリングに対する保護がないため、保守に不要なコストがかかります。
では、1単位の振る舞いとはなんでしょうか。

### モックの使用

ここではモックの使用について説明していきます。大事なことなので初めに述べておきますが、モックの濫用は厳禁です。理由としては、以下の通りです。

- テスト範囲を不用意に狭めてしまうから
- テストで検出してほしいバグが隠れてしまう可能性が高くなるから
- 

モックを置く位置にも気をつけないといけません。なるべくアプリケーションの境界に配置するべきだと考えています。

### テスト手法

では、ここからは何をテストするのかというトピックに移ります。テスト対象となるシステムを決定してから、次にどのような振る舞いをテストするのかを決定するのですが、対象の振る舞いには複数の選択肢があります。

- 実行後のシステムの出力
- 実行後のシステム状態
- システム間コミュニケーション

基本的に、実装の詳細に触れない「出力値」のテストが最も優先的に選択されるべきです。もちろんシステムによってはそれが不可能なケースがあるので、その場合に限り、「状態」のテストを行うようにすると、最も価値のあるテストになると考えています。
このように出力値をテストする手法を出力値ベーステストと呼びます。ここから先はテスト手法を出力値ベーステストに限定して話を進めます。

### 3Aパターン（Arrange-Act-Assert）

テストコードの設計についても見ていこうと思います。先ほどは何をテストとして確認対象とするのかという点での話でしたが、ここではテストケースの一連の設計について見ていきます。
1つのテストケースにおいて、以下のような流れに沿った3Aパターンと呼ばれるテストコード設計が保守性に優れていると考えています。

1. Arrange（準備フェーズ）
2. Act（実行フェーズ）
3. Assert（確認フェーズ）

こちらについては、あまりにも百聞は一件にしかず案件なのでサンプルコードを載せておきます。

:::details 3Aパターンのサンプルコード
```ts:dd

```
:::

この流れに沿えないようなテストケースには、私自身出会ったことがないため、特にデメリットがない設計だと思っています。さらにこれが組織の中でのスタンダードになれば、コメント行を不要にして、空行だけでフェーズを区別できるという状態にもなり、コードを極力シンプルにして管理することも可能です。

## おわりに

### ClaudeCode対応

私がテストをClaudeCodeに作成させる際に読み込ませるCLAUDE.mdを置いておきます。ここまで紹介したテスト設計の考え方をまとめているだけのものです。もしよければ使ってください。

:::details テスト作成特化の CLAUDE.md
```md:CLAUDE.md
## テスト
```
:::